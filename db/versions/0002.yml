version: 2
migrationScript: |-
  begin
    alter table secrets add column expires timestamp;
    update secrets set expires=now() + interval '1000 years';
    alter table secrets alter column expires set not null;
  end
methods:
  get_secret_with_expires:
    description: |-
      Read the secret associated with some key. If the secret has recently expired, the response code 410 is returned.
      If the caller lacks the scope necessary to get the secret, the call will fail with a 403 code regardless of
      whether the secret exists.
    mode: read
    serviceName: secrets
    args: name text
    returns: table (secret text, expires timestamp)
    body: |-
      begin
        return query select secrets.secret, secrets.expires from secrets where secrets.name = get_secret_with_expires.name;
      end
  list_secrets_with_expires:
    description: |-
      List the names of all secrets.
      By default this end-point will try to return up to 1000 secret names in one request. But it may return less,
      even if more tasks are available. It may also return a `continuationToken` even though there are no more results.
      However, you can only be sure to have seen all results if you keep calling `listTaskGroup` with the last
      `continuationToken` until you get a result without a `continuationToken`. If you are not interested in listing
      all the members at once, you may use the query-string option `limit` to return fewer.
    mode: read
    serviceName: secrets
    args: ''
    returns: table (name text, expires timestamp)
    body: |-
      begin
        return query select secrets.name as name, secrets.expires as expires from secrets;
      end
  remove_secret:
    description: |-
      Delete the secret associated with some key.
    mode: write
    serviceName: secrets
    args: name text
    returns: void
    body: |-
      begin
        delete from secrets where secrets.name = remove_secret.name;
      end
  set_secret_with_expires:
    description: |-
      Set the secret associated with some key. If the secret already exists, it is updated instead.
    mode: write
    serviceName: secrets
    args: name text, secret text, expires timestamp
    returns: void
    body: |-
      begin
        insert into secrets values (
          set_secret_with_expires.name,
          set_secret_with_expires.secret,
          set_secret_with_expires.expires
        )
        on conflict on constraint secrets_pkey do
          update set secret=EXCLUDED.secret, expires=EXCLUDED.expires;
      end
