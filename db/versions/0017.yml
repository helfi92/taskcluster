version: 17
migrationScript: 0017-migration.sql
downgradeScript: 0017-downgrade.sql
methods:
  namespaces_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: index
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select
          namespaces_entities_load.partition_key,
          namespaces_entities_load.row_key,
          jsonb_build_object(
            'PartitionKey', sha512(parent),
            'RowKey', encode_string_key(name),
            'parent', parent,
            'name', name,
            'expires', expires) as value,
          1 as version,
          index_namespaces.etag as etag
        from index_namespaces
        where
          sha512(index_namespaces.parent) = partition_key and
          index_namespaces.name = decode_string_key(row_key);
      end
  namespaces_entities_create:
    serviceName: index
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_row index_namespaces%ROWTYPE;
      begin
        select
          (properties ->> 'parent')::text,
          (properties ->> 'name')::text,
          (properties ->> 'expires')::timestamptz,
          public.gen_random_uuid()
        into new_row;
        if overwrite then
          raise exception 'overwrite not implemented';
        else
          execute 'insert into index_namespaces select $1.*' using new_row;
        end if;
        return new_row.etag;
      end
  namespaces_entities_remove:
    serviceName: index
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from index_namespaces
        where
          sha512(index_namespaces.parent) = namespaces_entities_remove.partition_key and
          index_namespaces.name = decode_string_key(namespaces_entities_remove.row_key)
        returning index_namespaces.etag;
      end
  namespaces_entities_modify:
    serviceName: index
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_row index_namespaces%ROWTYPE;
      begin
        select
          (properties ->> 'parent')::text,
          (properties ->> 'name')::text,
          (properties ->> 'expires')::timestamptz,
          public.gen_random_uuid() as etag
        into new_row;
        update index_namespaces
        set (
          parent,
          name,
          expires,
          etag
        ) = (
          new_row.parent,
          new_row.name,
          new_row.expires,
          new_row.etag
        )
        where
          sha512(index_namespaces.parent) = namespaces_entities_modify.partition_key and
          index_namespaces.name = decode_string_key(namespaces_entities_modify.row_key) and
          index_namespaces.etag = namespaces_entities_modify.old_etag;
        if found then
          return query select new_row.etag;
          return;
        end if;
        perform index_namespaces.etag from index_namespaces
        where
          sha512(index_namespaces.parent) = namespaces_entities_modify.partition_key and
          index_namespaces.name = decode_string_key(namespaces_entities_modify.row_key);
        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise warning 'no such row... % pk: %, row_key %, new_row.etag %, old_etag %', properties, partition_key, row_key, new_row.etag, old_etag;
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  namespaces_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: index
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        cond text[];
        exp_cond_operator text;
        exp_cond_operand timestamptz;
        partition_key_var text;
        row_key_var text;
      begin
        if not condition is null then
          cond := regexp_split_to_array(condition, '\s+');
          exp_cond_operator := cond[4];
          exp_cond_operand := cond[5] :: timestamptz;
          return query select
            sha512(parent) as partition_key,
            encode_string_key(name) as row_key,
            jsonb_build_object(
              'PartitionKey', sha512(parent),
              'RowKey', encode_string_key(name),
              'parent', parent,
              'name', name,
              'expires', expires) as value,
            1 as version,
            index_namespaces.etag as etag from index_namespaces
          where
            (namespaces_entities_scan.pk is null or sha512(parent) = namespaces_entities_scan.pk) and
            (namespaces_entities_scan.rk is null or decode_string_key(namespaces_entities_scan.rk) = name) and
            case
              when exp_cond_operator = '=' then expires = exp_cond_operand
              when exp_cond_operator = '<' then expires < exp_cond_operand
              when exp_cond_operator = '<=' then expires <= exp_cond_operand
              when exp_cond_operator = '>' then expires > exp_cond_operand
              when exp_cond_operator = '>=' then expires >= exp_cond_operand
              else expires <> exp_cond_operand
            end
          order by partition_key, index_namespaces.name
          limit case
            when (size is not null and size > 0) then size + 1
            else null
          end
          offset case
            when (page is not null and page > 0) then page
            else 0
          end;
        else
          return query select
            sha512(parent) as partition_key,
            encode_string_key(name) as row_key,
            jsonb_build_object(
              'PartitionKey', sha512(parent),
              'RowKey', encode_string_key(name),
              'parent', parent,
              'name', name,
              'expires', expires) as value,
            1 as version,
            index_namespaces.etag as etag from index_namespaces
          where
            (namespaces_entities_scan.pk is null or sha512(parent) = namespaces_entities_scan.pk) and
            (namespaces_entities_scan.rk is null or decode_string_key(namespaces_entities_scan.rk) = name)
          order by partition_key, index_namespaces.name
          limit case
            when (size is not null and size > 0) then size + 1
            else null
          end
          offset case
            when (size is not null and size > 0 and page is not null and page > 0) then page
            else 0
          end;
        end if;
      end

  get_index_namespaces:
    description: |-
      Get existing index_namespaces filtered by the optional arguments,
      ordered by the `parent` and `name`.
      If the pagination arguments are both NULL, all rows are returned.
      Otherwise, page_size rows are returned at offset page_offset.
    mode: read
    serviceName: index
    args: parent_in text, name_in text, page_size_in integer, page_offset_in integer
    returns: table(parent text, name text, expires timestamptz)
    body: |-
      begin
        return query
        select
          index_namespaces.parent,
          index_namespaces.name,
          index_namespaces.expires
        from index_namespaces
        where
          (index_namespaces.parent = parent_in or parent_in is null) and
          (index_namespaces.name = name_in or name_in is null) and
          (index_namespaces.expires > now())
        -- we previously used to order by the hashed parent but there's probably no need to add this complication.
        order by index_namespaces.parent, name
        limit get_page_limit(page_size_in)
        offset get_page_offset(page_offset_in);
      end
  create_index_namespace:
    description: |-
      Create a new namespace. Raises UNIQUE_VIOLATION if the namespace already exists.
      Returns the etag of the newly created namespace.
    mode: write
    serviceName: index
    args: parent_in text, name_in text, expires_in timestamptz
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        insert
          into index_namespaces (parent, name, expires, etag)
          values (parent_in, name_in, expires_in, new_etag);
        return new_etag;
      end
  get_index_namespace:
    description: |-
      Get a namespace. The returned table will have one or
      (if no such namespace is defined) an exception will be raised with error code 'P0002'.
    mode: read
    serviceName: index
    args: parent_in text, name_in text
    returns: table(parent text, name text, expires timestamptz, etag uuid)
    body: |-
      declare
        new_row index_namespaces%ROWTYPE;
      begin
        select
          index_namespaces.parent,
          index_namespaces.name,
          index_namespaces.expires,
          index_namespaces.etag
        from index_namespaces
        where
          index_namespaces.parent = parent_in and
          index_namespaces.name = name_in
        into new_row;
        if found then
          return query select new_row.parent, new_row.name, new_row.expires, new_row.etag;
          return;
        end if;

        raise exception 'no such row' using errcode = 'P0002';
      end
  update_index_namespace:
    serviceName: index
    description: |-
      Update a namespace.
      Returns the up-to-date namespace row that have the same parent and name.
      If the row is not found then an exception with code 'P0002' is thrown.
    mode: write
    args: parent_in text, name_in text, expires_in timestamptz
    returns: table(parent text, name text, expires timestamptz, etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
        updated_row index_namespaces%ROWTYPE;
      begin
        update index_namespaces
        set (expires, etag) = (
          coalesce(expires_in, index_namespaces.expires),
          new_etag
        )
        where
          index_namespaces.parent = parent_in and
          index_namespaces.name = name_in
        returning
          index_namespaces.parent,
          index_namespaces.name,
          index_namespaces.expires,
          index_namespaces.etag
        into updated_row;

        if found then
          return query select
            updated_row.parent,
            updated_row.name,
            updated_row.expires,
            updated_row.etag;
          return;
        end if;

        raise exception 'no such row' using errcode = 'P0002';
      end
  expire_index_namespaces:
    description: |-
      Expire index_namespaces that come before the current time.
      Returns a count of rows that have been deleted.
    mode: write
    serviceName: index
    args: ''
    returns: integer
    body: |-
      declare
        count integer;
      begin
        delete from index_namespaces where index_namespaces.expires < now();
        if found then
          get diagnostics count = row_count;
          return count;
        end if;
        return 0;
      end
  indexed_tasks_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: index
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select
          indexed_tasks_entities_load.partition_key,
          indexed_tasks_entities_load.row_key,
          entity_buf_encode(
            jsonb_build_object(
              'PartitionKey', sha512(namespace),
              'RowKey', encode_string_key(name),
              'namespace', namespace,
              'name', name,
              'rank', rank,
              'taskId', task_id,
              'expires', expires),
            'data', data::text) as value,
          1 as version,
          indexed_tasks.etag as etag
        from indexed_tasks
        where
          sha512(indexed_tasks.namespace) = partition_key and
          indexed_tasks.name = decode_string_key(row_key);
      end
  indexed_tasks_entities_create:
    serviceName: index
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_row indexed_tasks%ROWTYPE;
      begin
        select
          (properties ->> 'namespace')::text,
          (properties ->> 'name')::text,
          (properties ->> 'rank')::text,
          (properties ->> 'taskId')::text,
          entity_buf_decode(properties, 'data')::jsonb,
          (properties ->> 'expires')::timestamptz,
          public.gen_random_uuid()
        into new_row;
        if overwrite then
          raise exception 'overwrite not implemented';
        else
          execute 'insert into indexed_tasks select $1.*' using new_row;
        end if;
        return new_row.etag;
      end
  indexed_tasks_entities_remove:
    serviceName: index
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from indexed_tasks
        where
          sha512(indexed_tasks.namespace) = indexed_tasks_entities_remove.partition_key and
          indexed_tasks.name = decode_string_key(indexed_tasks_entities_remove.row_key)
        returning indexed_tasks.etag;
      end
  indexed_tasks_entities_modify:
    serviceName: index
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_row indexed_tasks%ROWTYPE;
      begin
        select
          (properties ->> 'namespace')::text,
          (properties ->> 'name')::text,
          (properties ->> 'rank')::integer,
          (properties ->> 'taskId')::text,
          entity_buf_decode(properties, 'data')::jsonb,
          (properties ->> 'expires')::timestamptz,
          public.gen_random_uuid() as etag
        into new_row;
        update indexed_tasks
        set (
          namespace,
          name,
          rank,
          task_id,
          data,
          expires,
          etag
        ) = (
          new_row.namespace,
          new_row.name,
          new_row.rank,
          new_row.task_id,
          new_row.data,
          new_row.expires,
          new_row.etag
        )
        where
          sha512(indexed_tasks.namespace) = indexed_tasks_entities_modify.partition_key and
          indexed_tasks.name = decode_string_key(indexed_tasks_entities_modify.row_key) and
          indexed_tasks.etag = indexed_tasks_entities_modify.old_etag;
        if found then
          return query select new_row.etag;
          return;
        end if;
        perform indexed_tasks.etag from indexed_tasks
        where
          sha512(indexed_tasks.namespace) = indexed_tasks_entities_modify.partition_key and
          indexed_tasks.name = decode_string_key(indexed_tasks_entities_modify.row_key);
        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise warning 'no such row... % pk: %, row_key %, new_row.etag %, old_etag %', properties, partition_key, row_key, new_row.etag, old_etag;
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  indexed_tasks_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: index
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        cond text[];
        exp_cond_operator text;
        exp_cond_operand timestamptz;
        partition_key_var text;
        row_key_var text;
      begin
        if not condition is null then
          cond := regexp_split_to_array(condition, '\s+');
          exp_cond_operator := cond[4];
          exp_cond_operand := cond[5] :: timestamptz;
          return query select
            sha512(namespace) as partition_key,
            encode_string_key(name) as row_key,
            entity_buf_encode(
              jsonb_build_object(
                'PartitionKey', sha512(namespace),
                'RowKey', encode_string_key(name),
                'namespace', namespace,
                'name', name,
                'rank', rank,
                'taskId', task_id,
                'expires', expires),
              'data', data::text) as value,
            1 as version,
            indexed_tasks.etag as etag from indexed_tasks
          where
            (indexed_tasks_entities_scan.pk is null or sha512(namespace) = indexed_tasks_entities_scan.pk) and
            (indexed_tasks_entities_scan.rk is null or decode_string_key(indexed_tasks_entities_scan.rk) = name) and
            case
              when exp_cond_operator = '=' then expires = exp_cond_operand
              when exp_cond_operator = '<' then expires < exp_cond_operand
              when exp_cond_operator = '<=' then expires <= exp_cond_operand
              when exp_cond_operator = '>' then expires > exp_cond_operand
              when exp_cond_operator = '>=' then expires >= exp_cond_operand
              else expires <> exp_cond_operand
            end
          order by partition_key, indexed_tasks.name
          limit case
            when (size is not null and size > 0) then size + 1
            else null
          end
          offset case
            when (page is not null and page > 0) then page
            else 0
          end;
        else
          return query select
            sha512(namespace) as partition_key,
            encode_string_key(name) as row_key,
            entity_buf_encode(
              jsonb_build_object(
                'PartitionKey', sha512(namespace),
                'RowKey', encode_string_key(name),
                'namespace', namespace,
                'name', name,
                'rank', rank,
                'taskId', task_id,
                'expires', expires),
              'data', data::text) as value,
            1 as version,
            indexed_tasks.etag as etag from indexed_tasks
          where
            (indexed_tasks_entities_scan.pk is null or sha512(namespace) = indexed_tasks_entities_scan.pk) and
            (indexed_tasks_entities_scan.rk is null or decode_string_key(indexed_tasks_entities_scan.rk) = name)
          order by partition_key, indexed_tasks.name
          limit case
            when (size is not null and size > 0) then size + 1
            else null
          end
          offset case
            when (size is not null and size > 0 and page is not null and page > 0) then page
            else 0
          end;
        end if;
      end
  get_indexed_tasks:
    description: |-
      Get existing indexed tasks filtered by the optional arguments,
      ordered by the `namespace` and `name`.
      If the pagination arguments are both NULL, all rows are returned.
      Otherwise, page_size rows are returned at offset page_offset.
    mode: read
    serviceName: index
    args: namespace_in text, name_in text, page_size_in integer, page_offset_in integer
    returns: table(namespace text, name text, rank integer, task_id text, data jsonb, expires timestamptz)
    body: |-
      begin
        return query
        select
          indexed_tasks.namespace,
          indexed_tasks.name,
          indexed_tasks.rank,
          indexed_tasks.task_id,
          indexed_tasks.data,
          indexed_tasks.expires
        from indexed_tasks
        where
          (indexed_tasks.namespace = namespace_in or namespace_in is null) and
          (indexed_tasks.name = name_in or name_in is null) and
          (indexed_tasks.expires > now())
        -- we previously used to order by the hashed namespace but there's probably no need to add this complication.
        order by indexed_tasks.namespace, name
        limit get_page_limit(page_size_in)
        offset get_page_offset(page_offset_in);
      end
  create_indexed_task:
    description: |-
      Create a new indexed task. Raises UNIQUE_VIOLATION if the indexed task already exists.
      Returns the etag of the newly created indexed task.
    mode: write
    serviceName: index
    args: namespace_in text, name_in text, rank_in integer, task_id_in text, data_in jsonb, expires_in timestamptz
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        insert
          into indexed_tasks (namespace, name, rank, task_id, data, expires, etag)
          values (namespace_in, name_in, rank_in, task_id_in, data_in, expires_in, new_etag);
        return new_etag;
      end
  get_indexed_task:
    description: |-
      Get a non-expired indexed task. The returned table will have one row. If no such indexed task is defined then
      an exception will be raised with error code 'P0002'.
    mode: read
    serviceName: index
    args: namespace_in text, name_in text
    returns: table(namespace text, name text, rank integer, task_id text, data jsonb, expires timestamptz, etag uuid)
    body: |-
      declare
        new_row indexed_tasks%ROWTYPE;
      begin
        select
          indexed_tasks.namespace,
          indexed_tasks.name,
          indexed_tasks.rank,
          indexed_tasks.task_id,
          indexed_tasks.data,
          indexed_tasks.expires,
          indexed_tasks.etag
        from indexed_tasks
        where
          indexed_tasks.namespace = namespace_in and
          indexed_tasks.name = name_in and
          indexed_tasks.expires > now()
        into new_row;
        if found then
          return query select new_row.namespace, new_row.name, new_row.rank, new_row.task_id, new_row.data, new_row.expires, new_row.etag;
          return;
        end if;

        raise exception 'no such row' using errcode = 'P0002';
      end
  update_indexed_task:
    serviceName: index
    description: |-
      Update an indexed task.
      Returns the up-to-date indexed task row that have the same namespace and name.
      If the etag argument is empty then the update will overwrite the matched row.
      Else, the function will fail if the etag is out of date. This is useful for concurency handling.
    mode: write
    args: namespace_in text, name_in text, rank_in integer, task_id_in text, data_in jsonb, expires_in timestamptz, etag_in uuid
    returns: table(namespace text, name text, rank integer, task_id text, data jsonb, expires timestamptz, etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
        updated_row indexed_tasks%ROWTYPE;
      begin
        update indexed_tasks
        set (rank, task_id, data, expires, etag) = (
          coalesce(rank_in, indexed_tasks.rank),
          coalesce(task_id_in, indexed_tasks.task_id),
          coalesce(data_in, indexed_tasks.data),
          coalesce(expires_in, indexed_tasks.expires),
          new_etag
        )
        where
          indexed_tasks.namespace = namespace_in and
          indexed_tasks.name = name_in and
          indexed_tasks.etag = coalesce(etag_in, indexed_tasks.etag)
        returning
          indexed_tasks.namespace,
          indexed_tasks.name,
          indexed_tasks.rank,
          indexed_tasks.task_id,
          indexed_tasks.data,
          indexed_tasks.expires,
          indexed_tasks.etag
        into updated_row;

        if found then
          return query select
            updated_row.namespace,
            updated_row.name,
            updated_row.rank,
            updated_row.task_id,
            updated_row.data,
            updated_row.expires,
            updated_row.etag;
          return;
        end if;

        perform indexed_tasks.etag from indexed_tasks
          where
            indexed_tasks.namespace = namespace_in and
            indexed_tasks.name = name_in;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  expire_indexed_tasks:
    description: |-
      Expire indexed tasks that come before the current time.
      Returns a count of rows that have been deleted.
    mode: write
    serviceName: index
    args: ''
    returns: integer
    body: |-
      declare
        count integer;
      begin
        delete from indexed_tasks where indexed_tasks.expires < now();
        if found then
          get diagnostics count = row_count;
          return count;
        end if;
        return 0;
      end
