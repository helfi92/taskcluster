version: 17
migrationScript: 0017-migration.sql
downgradeScript: 0017-downgrade.sql
methods:
  queue_artifacts_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        decoded_composite_key text[];
      begin
        decoded_composite_key := decode_composite_key(queue_artifacts_entities_load.partition_key);
        return query
        select
          queue_artifacts_entities_load.partition_key,
          queue_artifacts_entities_load.row_key,
          entity_buf_encode(
            jsonb_build_object(
              'PartitionKey', queue_artifacts_entities_load.partition_key,
              'RowKey', queue_artifacts_entities_load.row_key,
              'taskId', slugid_to_uuid(task_id),
              'runId', run_id,
              'name', name,
              'storageType', storage_type,
              'contentType', content_type,
              'present', present,
              'expires', expires),
            'details', details::text) as value,
          1 as version,
          queue_artifacts.etag as etag
        from queue_artifacts
        where
          queue_artifacts.task_id = decoded_composite_key[1] and queue_artifacts.run_id::text = decoded_composite_key[2] and queue_artifacts.name = decode_string_key(queue_artifacts_entities_load.row_key);
      end
  queue_artifacts_entities_create:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_row queue_artifacts%ROWTYPE;
      begin
        select
          uuid_to_slugid(properties ->> 'taskId'),
          (properties ->> 'runId')::integer,
          (properties ->> 'name')::text,
          (properties ->> 'storageType')::text,
          (properties ->> 'contentType')::text,
          entity_buf_decode(properties, 'details')::jsonb,
          (properties ->> 'present')::boolean,
          (properties ->> 'expires')::timestamptz,
          public.gen_random_uuid()
        into new_row;
        if overwrite then
          raise exception 'overwrite not implemented';
        else
          execute 'insert into queue_artifacts select $1.*' using new_row;
        end if;
        return new_row.etag;
      end
  queue_artifacts_entities_remove:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      declare
        decoded_composite_key text[];
      begin
        decoded_composite_key := decode_composite_key(queue_artifacts_entities_remove.partition_key);
        return query delete from queue_artifacts
        where
          queue_artifacts.task_id = decoded_composite_key[1] and queue_artifacts.run_id::text = decoded_composite_key[2] and queue_artifacts.name = decode_string_key(queue_artifacts_entities_remove.row_key)
        returning queue_artifacts.etag;
      end
  queue_artifacts_entities_modify:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_row queue_artifacts%ROWTYPE;
        decoded_composite_key text[];
      begin
        decoded_composite_key := decode_composite_key(queue_artifacts_entities_modify.partition_key);
        select
          (properties ->> 'taskId')::text,
          (properties ->> 'runId')::integer,
          (properties ->> 'name')::text,
          (properties ->> 'storageType')::text,
          (properties ->> 'contentType')::text,
          entity_buf_decode(properties, 'details')::jsonb,
          (properties ->> 'present')::boolean,
          (properties ->> 'expires')::timestamptz,
          public.gen_random_uuid()
        into new_row;
        update queue_artifacts
        set (
          storage_type,
          content_type,
          details,
          present,
          expires,
          etag
        ) = (
          new_row.storage_type,
          new_row.content_type,
          new_row.details,
          new_row.present,
          new_row.expires,
          new_row.etag
        )
        where
          queue_artifacts.task_id = decoded_composite_key[1] and
          queue_artifacts.run_id::text = decoded_composite_key[2] and
          queue_artifacts.name = decode_string_key(queue_artifacts_entities_modify.row_key) and
          queue_artifacts.etag = queue_artifacts_entities_modify.old_etag;
        if found then
          return query select new_row.etag;
          return;
        end if;
        perform queue_artifacts.etag from queue_artifacts
        where
          queue_artifacts.task_id = decoded_composite_key[1] and
          queue_artifacts.run_id::text = decoded_composite_key[2] and
          queue_artifacts.name = decode_string_key(queue_artifacts_entities_modify.row_key);
        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  queue_artifacts_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        cond text[];
        exp_cond_operator text;
        exp_cond_operand timestamptz;
        partition_key_var text;
        row_key_var text;
        decoded_composite_key text[];
      begin
        decoded_composite_key := decode_composite_key(queue_artifacts_entities_scan.pk);
        if not condition is null then
          cond := regexp_split_to_array(condition, '\s+');
          exp_cond_operator := cond[4];
          exp_cond_operand := cond[5] :: timestamptz;

          return query select
            encode_composite_key(queue_artifacts.task_id, queue_artifacts.run_id::text) as partition_key,
            encode_string_key(queue_artifacts.name) as row_key,
            entity_buf_encode(
              jsonb_build_object(
                'PartitionKey', encode_composite_key(queue_artifacts.task_id, queue_artifacts.run_id::text),
                'RowKey', name,
                'taskId', slugid_to_uuid(task_id),
                'runId', run_id,
                'name', name,
                'storageType', storage_type,
                'contentType', content_type,
                'present', present,
                'expires', expires
              ),
            'details', details::text) as value,
            1 as version,
            queue_artifacts.etag as etag from queue_artifacts
          where
            (queue_artifacts_entities_scan.pk is null or queue_artifacts_entities_scan.pk = decoded_composite_key[1] || '~' || decoded_composite_key[2]) and
            (queue_artifacts_entities_scan.rk is null or queue_artifacts_entities_scan.rk = name) and
            case
              when exp_cond_operator = '=' then expires = exp_cond_operand
              when exp_cond_operator = '<' then expires < exp_cond_operand
              when exp_cond_operator = '<=' then expires <= exp_cond_operand
              when exp_cond_operator = '>' then expires > exp_cond_operand
              when exp_cond_operator = '>=' then expires >= exp_cond_operand
              else expires <> exp_cond_operand
            end
          order by queue_artifacts.task_id, queue_artifacts.run_id, queue_artifacts.name
          limit case
            when (size is not null and size > 0) then size + 1
            else null
          end
          offset case
            when (page is not null and page > 0) then page
            else 0
          end;
        else
          return query select
            encode_composite_key(queue_artifacts.task_id, queue_artifacts.run_id::text) as partition_key,
            encode_string_key(queue_artifacts.name) as row_key,
            entity_buf_encode(
              jsonb_build_object(
                'PartitionKey', encode_composite_key(queue_artifacts.task_id, queue_artifacts.run_id::text),
                'RowKey', name,
                'taskId', slugid_to_uuid(task_id),
                'runId', run_id,
                'name', name,
                'storageType', storage_type,
                'contentType', content_type,
                'present', present,
                'expires', expires),
              'details', details::text) as value,
            1 as version,
            queue_artifacts.etag as etag from queue_artifacts
          where
            (queue_artifacts_entities_scan.pk is null or (queue_artifacts.task_id = decoded_composite_key[1] and queue_artifacts.run_id::text = decoded_composite_key[2])) and
            (queue_artifacts_entities_scan.rk is null or queue_artifacts_entities_scan.rk = name)
          order by queue_artifacts.task_id, queue_artifacts.run_id, queue_artifacts.name
          limit case
            when (size is not null and size > 0) then size + 1
            else null
          end
          offset case
            when (size is not null and size > 0 and page is not null and page > 0) then page
            else 0
          end;
        end if;
      end
  expire_queue_artifacts:
    description: |-
      Expire queue artifacts that come before the current time.
      Returns a count of rows that have been deleted.
    mode: write
    serviceName: queue
    args: ''
    returns: integer
    body: |-
      declare
        count integer;
      begin
        delete from queue_artifacts where queue_artifacts.expires < now();
        if found then
          get diagnostics count = row_count;
          return count;
        end if;
        return 0;
      end
  create_queue_artifact:
    description: |-
      Create a new artifact. Raises UNIQUE_VIOLATION if the artifact already exists.
      Returns the etag of the newly created artifact.
    mode: write
    serviceName: queue
    args: task_id_in text, run_id_in integer, name_in text, storage_type_in text, content_type_in text, details_in jsonb, present_in boolean, expires_in timestamptz
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        insert
          into queue_artifacts (task_id, run_id, name, storage_type, content_type, details, present, expires, etag)
          values (task_id_in, run_id_in, name_in, storage_type_in, content_type_in, details_in, present_in, expires_in, new_etag);
        return new_etag;
      end
  update_queue_artifact:
    serviceName: queue
    description: |-
      Update a queue artifact.
      Returns the up-to-date artifact row that have the same task id, run id, and name.
      If the etag argument is empty then the update will overwrite the matched row.
      Else, the function will fail if the etag is out of date. This is useful for concurency handling.
    mode: write
    args: task_id_in text, run_id_in integer, name_in text, details_in jsonb, expires_in timestamptz, etag_in uuid
    returns: table(task_id text, run_id integer, name text, storage_type text, content_type text, details jsonb, present boolean, expires timestamptz, etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
        updated_row queue_artifacts%ROWTYPE;
      begin
        update queue_artifacts
        set (details, expires, etag) = (
          coalesce(details_in, queue_artifacts.details),
          coalesce(expires_in, queue_artifacts.expires),
          new_etag
        )
        where
          queue_artifacts.task_id = task_id_in and
          queue_artifacts.run_id = run_id_in and
          queue_artifacts.name = name_in and
          queue_artifacts.etag = coalesce(etag_in, queue_artifacts.etag)
        returning
          queue_artifacts.task_id,
          queue_artifacts.run_id,
          queue_artifacts.name,
          queue_artifacts.storage_type,
          queue_artifacts.content_type,
          queue_artifacts.details,
          queue_artifacts.present,
          queue_artifacts.expires,
          queue_artifacts.etag
        into updated_row;
        if found then
          return query select
            updated_row.task_id,
            updated_row.run_id,
            updated_row.name,
            updated_row.storage_type,
            updated_row.content_type,
            updated_row.details,
            updated_row.present,
            updated_row.expires,
            updated_row.etag;
          return;
        end if;
        perform queue_artifacts.etag from queue_artifacts
          where
            queue_artifacts.task_id = task_id_in and
            queue_artifacts.run_id = run_id_in and
            queue_artifacts.name = name_in;
        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  delete_queue_artifact:
    description: |-
      Delete a queue artifact.
    mode: write
    serviceName: queue
    args: task_id_in text, run_id_in integer, name_in text
    returns: void
    body: |-
      begin
        delete
        from queue_artifacts
        where
          queue_artifacts.task_id = task_id_in and
          queue_artifacts.run_id = run_id_in and
          queue_artifacts.name = name_in;
      end
  get_queue_artifact:
    description: |-
      Get a queue artifact. The returned table will have one or
      (if no such artifact is defined) an exception will be raised with error code 'P0002'.
    mode: read
    serviceName: queue
    args: task_id_in text, run_id_in integer, name_in text
    returns: table(task_id text, run_id integer, name text, storage_type text, content_type text, details jsonb, present boolean, expires timestamptz, etag uuid)
    body: |-
      declare
        new_row queue_artifacts%ROWTYPE;
      begin
        select
          queue_artifacts.task_id,
          queue_artifacts.run_id,
          queue_artifacts.name,
          queue_artifacts.storage_type,
          queue_artifacts.content_type,
          queue_artifacts.details,
          queue_artifacts.present,
          queue_artifacts.expires,
          queue_artifacts.etag
        from queue_artifacts
        where
          queue_artifacts.task_id = task_id_in and
          queue_artifacts.run_id = run_id_in and
          queue_artifacts.name = name_in
        into new_row;
        if found then
          return query select new_row.task_id, new_row.run_id, new_row.name, new_row.storage_type, new_row.content_type, new_row.details, new_row.present, new_row.expires, new_row.etag;
          return;
        end if;
        raise exception 'no such row' using errcode = 'P0002';
      end
